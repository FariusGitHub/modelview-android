http://en.wikipedia.org/wiki/Obj

  * List of Vertex vertices
  * List of Normal normals
  * List of Triangle tris
  * for each line
    * if line starts with "#", "o", "g", "mtllib", "usemtl", or "vt", continue
    * if line starts with "v", parse line as x, y or x, y, z vertex, add to vertices
    * else if line starts with "vn" parse line as x, y, z normal
      * normalize vector?
    * else if line starts with "f" parse line as face, 
      * use regex to find "(\d+)(?:/(\d`*`))?(?:/(\d`*`))?" repeatedly
        * group 1 is vertex pointer, use to pull vertex from vertices list
        * group 2 is vertex texture, we ignore
        * group 3 is vertex normal, use to pull normal from vertices list
      * use vertices, normals discovered by parsing all vertex elements to build triangle(s), using fan method
      * add each triangle to the list of triangles

notes: 
  # vertices are stored in CCW order, so we should not need to generate back faces
  # all indices start with one, which means we must subtract one before using them to index into the lists we are building
  # may need to build triangles after entire set of vertices, faces, and normals is built. can we assume that things are defined before they are referenced? if not, we can perhaps introduce the idea of a PointerTriangle that instead of having actual vertices, has pointers to vertices (and normals), which we then later ask it to convert to a real triangle given the complete list of vertices, normals
  # since normals can be specified, we should make them a field of a triangle, not just a function of the triangle that builds the normal dynamically. triangle construction can optionally accept a normal, but if not present, is calculated at time of construction
  # may want to introduce a Normal class. we could re-use Vertex, but a normal doesn't have color. or we build a hierarchy. Vertex extends Point and adds color. Normal is a point that can normalize itself. 